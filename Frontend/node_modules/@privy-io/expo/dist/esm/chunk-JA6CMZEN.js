import{a as P,b as D,d as l}from"./chunk-OWCFWPAL.js";import{useEffect as Ir}from"react";import{create as Or}from"zustand";var mt=Or(()=>({status:"disconnected"})),ye=()=>mt.getState().onNeedsRecovery,Lr=e=>{Ir(()=>{mt.setState({onNeedsRecovery:e==null?void 0:e.onNeedsRecovery})},[e==null?void 0:e.onNeedsRecovery])};import{applicationId as pt}from"expo-application";import*as F from"expo-secure-store";import{PrivyClientError as Mr}from"@privy-io/js-sdk-core";var yt=()=>{if(typeof pt!="string")throw new Mr({error:"Cannot determine native application ID. Please make sure `expo-application` is installed as a dependency and that `ios.bundleId` or `android.package` is set.",code:"invalid_native_app_id"});return pt};function ft(e){return{get(t){return e.get(t.replaceAll(":","-"))},put(t,r){return e.put(t.replaceAll(":","-"),r)},del(t){return e.del(t.replaceAll(":","-"))},getKeys:()=>l(this,null,function*(){return[]})}}var fe={get(e){return F.getItemAsync(e,{keychainAccessible:F.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY})},put(e,t){return F.setItemAsync(e,t,{keychainAccessible:F.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY})},del(e){return F.deleteItemAsync(e,{keychainAccessible:F.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY})},getKeys:()=>l(void 0,null,function*(){return[]})};import{digest as Tr}from"expo-crypto";import Nr from"@privy-io/js-sdk-core";var gt={name:"@privy-io/expo",version:"0.60.3",description:"Expo client for the Privy Auth API",keywords:["authentication","authorization","identity","privacy","privy","user data","react-native","expo","web3"],homepage:"https://docs.privy.io",bugs:{url:"https://privy.io/slack"},license:"Apache-2.0",author:"privy.io",exports:{".":{require:"./dist/index.js",import:"./dist/esm/index.js",types:"./dist/index.d.ts"},"./passkey":{require:"./dist/passkey.js",import:"./dist/esm/passkey.js",types:"./dist/passkey.d.ts"},"./smart-wallets":{require:"./dist/smart-wallets.js",import:"./dist/esm/smart-wallets.js",types:"./dist/smart-wallets.d.ts"},"./extended-chains":{require:"./dist/extended-chains.js",import:"./dist/esm/extended-chains.js",types:"./dist/extended-chains.d.ts"},"./ui":{require:"./dist/ui.js",import:"./dist/esm/ui.js",types:"./dist/ui.d.ts"},"./connectors":{require:"./dist/connectors.js",import:"./dist/esm/connectors.js",types:"./dist/connectors.d.ts"}},main:"./dist/esm/index.js",source:"./src/index.ts",types:"./dist/index.d.ts",files:["dist/**/*","LICENSE","README.md"],scripts:{build:"tsup --clean --minify","check-types":"tsc --noEmit",clean:"rm -rf dist .turbo","clean:reset":"rm -rf dist .turbo node_modules",dev:"tsup --watch",format:'eslint "src/**/*.{ts,tsx,js,jsx}" --fix',"generate-types":"tsup --dts-only",lint:'eslint "src/**/*.{ts,tsx,js,jsx}"',test:"jest"},browserslist:["defaults","node >= 18","not op_mini all"],dependencies:{"@privy-io/api-types":"0.2.0","@privy-io/js-sdk-core":"0.58.1","@scure/base":"^1.2.4","react-fast-compare":"^3.2.2",tweetnacl:"^1.0.3",zustand:"^5.0.4"},devDependencies:{"@privy-io/eslint-config-custom":"*","@privy-io/eslint-plugin-privy-rules":"*","@privy-io/tsconfig":"*","@simplewebauthn/types":"9.0.1","@solana/web3.js":"^1.98.0","@svgr/core":"^8.1.0","@svgr/plugin-jsx":"^8.1.0","@svgr/plugin-svgo":"^8.1.0","@testing-library/react-native":"^13.1.0","@tsconfig/node16-strictest-esm":"^1.0.3","@types/jest":"^29.1.2","@types/react":"18.3.18",buffer:"^5.4.3","eslint-plugin-react-hooks":"^5.0.0-canary-7118f5dd7-20230705",expo:"52.0.37","expo-apple-authentication":"7.1.3","expo-application":"6.0.2","expo-clipboard":"7.0.1","expo-crypto":"14.0.2",jest:"^29.7.0","jest-expo":"52.0.5","lucide-react-native":"^0.474.0",react:"^18.3.1","react-native":"0.77.1","react-test-renderer":"^18.3.1",tsup:"^6.2.3",typescript:"~5.5.3"},peerDependencies:{"@expo-google-fonts/inter":"*","@privy-io/expo-native-extensions":"0.0.5","expo-apple-authentication":"*","expo-application":"*","expo-clipboard":"*","expo-crypto":"*","expo-font":"*","expo-linking":"*","expo-secure-store":"*","expo-web-browser":"*",permissionless:"^0.2.47",react:"*","react-native":"*","react-native-passkeys":"^0.3.0","react-native-qrcode-styled":"*","react-native-safe-area-context":"*","react-native-svg":"*","react-native-webview":"*",viem:"^2.38.6"},peerDependenciesMeta:{"@expo-google-fonts/inter":{optional:!0},"expo-font":{optional:!0},permissionless:{optional:!0},viem:{optional:!0},"react-native-svg":{optional:!0},"expo-clipboard":{optional:!0},"react-native-qrcode-styled":{optional:!0},"react-native-safe-area-context":{optional:!0}},publishConfig:{access:"public"}};var ht=({appId:e,clientId:t,storage:r=fe,supportedChains:n,baseUrl:i,logLevel:o})=>new Nr({appId:e,clientId:t,supportedChains:n,storage:ft(r),sdkVersion:`expo:${gt.version}`,nativeAppIdentifier:yt(),crypto:{digest:Tr},baseUrl:i,logLevel:o});import{useCallback as at,useContext as xi}from"react";import{PrivyClientError as Pi}from"@privy-io/js-sdk-core";import Z,{useState as L,useMemo as _i,createContext as Ei,useCallback as Ae,useRef as le,useEffect as Sr,useContext as Ci}from"react";import{AppState as _r,View as ki}from"react-native";import{PrivyClientError as Er}from"@privy-io/js-sdk-core";import Dr from"react-fast-compare";import{create as jr}from"zustand";var ge=jr(()=>{}),wt=e=>ge.setState(t=>Dr(t,e)?t:e),W=ge.getState;import Br from"react";import{useCallback as Hr,useEffect as zr,useRef as qr}from"react";import{AppState as Gr}from"react-native";import Jr from"react-native-webview";import*as T from"expo-secure-store";function vt(e){return typeof e!="object"||e===null||!("event"in e&&typeof e.event=="string")||!("id"in e&&typeof e.id=="string")||!("data"in e&&typeof e.data=="object")||e.data===null?!1:e.event.startsWith("app:secure-storage:")}function bt(e){return l(this,null,function*(){switch(e.event){case"app:secure-storage:get":{let{key:t}=e.data,r=yield T.getItemAsync(Oe(t),{keychainAccessible:T.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY}).catch(n=>(console.warn("Failed to get the value from secure store",n),null));return{event:e.event,id:e.id,data:{value:r}}}case"app:secure-storage:remove":{let{key:t}=e.data,r=yield T.deleteItemAsync(Oe(t),{keychainAccessible:T.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY}).then(()=>!0).catch(n=>(console.warn("Failed to remove the value from secure store",n),!1));return{event:e.event,id:e.id,data:{success:r}}}case"app:secure-storage:set":{let{key:t,value:r}=e.data,n=yield T.setItemAsync(Oe(t),r,{keychainAccessible:T.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY}).then(()=>!0).catch(i=>(console.warn("Failed to write the value to secure store",i),!1));return{event:e.event,id:e.id,data:{success:n}}}}})}var Oe=e=>e.replaceAll(":","-");import Vr from"react-fast-compare";import{createStore as Kr,useStore as Le}from"zustand";var V=Kr()(()=>({user:null,proxyStatus:"loading"}));function b(){return V.getState().user}var Yi=V.subscribe.bind(V);function Me(e){V.setState(({user:t})=>Vr(t,e)?{}:{user:e})}var Fe=e=>V.setState({proxyStatus:e});function A(){return Le(V,e=>e.user)}function $i(){return Le(V,e=>!!e.user)}function K(){return Le(V,e=>e.proxyStatus!=="loading")}var Yr={shouldUseAppBackedStorage:!0},St=({client:e,isClientReady:t})=>{let r=qr(null);zr(()=>Gr.addEventListener("change",o=>l(void 0,null,function*(){o==="active"&&((yield e.embeddedWallet.ping(500))||(Fe("reloading"),e.embeddedWallet.reload()))})).remove,[e]);let n=Hr(i=>l(void 0,null,function*(){var s;let{data:o}=i.nativeEvent,a=JSON.parse(o);if(vt(a)){let d=yield bt(a);(s=r.current)==null||s.postMessage(JSON.stringify(d));return}e.embeddedWallet.onMessage(a)}),[e]);return t?Br.createElement(Jr,{style:{flex:1},ref:i=>{i&&(e.setMessagePoster(i),r.current=i)},cacheEnabled:!1,cacheMode:"LOAD_NO_CACHE",injectedJavaScriptObject:Yr,source:{uri:e.embeddedWallet.getURL()},webviewDebuggingEnabled:e.logger.level==="DEBUG",onLoad:()=>Fe("loaded"),onError:console.error,onMessage:n}):null};import{useCallback as Te,useEffect as kt,useMemo as Ne}from"react";import{errorIndicatesRecoveryIsNeeded as Qr,getAllUserEmbeddedSolanaWallets as Xr,getEntropyDetailsFromUser as Wt,PrivyClientError as re}from"@privy-io/js-sdk-core";import{getAllUserEmbeddedSolanaWallets as he,getEntropyDetailsFromAccount as _t,getUserEmbeddedEthereumWallet as $r,PrivyClientError as q}from"@privy-io/js-sdk-core";function Et(o){return l(this,arguments,function*({client:e,setSolanaWallet:t,createSolanaWalletCallbacks:r,setSolanaRecoveryFlowState:n,opts:i}){var a,s,d;t({status:"creating"});try{let{user:c}=yield e.user.get(),u=he(c),m=u[0],p=(a=$r(c))!=null?a:void 0;if(i!=null&&i.recoveryMethod&&i.recoveryMethod!=="privy")throw new q({code:"embedded_wallet_creation_error",error:"Unsupported recovery method for solana wallet."});if(!(i!=null&&i.createAdditional)&&m)throw new q({code:"embedded_wallet_creation_error",error:"Solana wallet already exists for this user. Set `createAdditional` to `true` to create another wallet"});let w,g;if(m){let y=p!=null?p:m,{entropyId:h,entropyIdVerifier:S}=_t(y),E=Math.max(...u.map(x=>x.wallet_index),0)+1,C=yield e.embeddedWallet.add({chainType:"solana",entropyId:h,entropyIdVerifier:S,hdWalletIndex:E}),k=he(C.user).find(x=>x.wallet_index===E);if(!k)throw new q({error:"Embedded wallet account not created",code:"embedded_wallet_creation_error"});w=yield e.embeddedWallet.getSolanaProvider(k,h,S),g=C.user}else{let y=yield e.embeddedWallet.createSolana({ethereumAccount:p}),h=he(y.user).find(k=>k.wallet_index===0);if(!h)throw new q({error:"Embedded wallet account not created",code:"embedded_wallet_creation_error"});let S=p!=null?p:h,{entropyId:E,entropyIdVerifier:C}=_t(S);w=yield e.embeddedWallet.getSolanaProvider(h,E,C),g=y.user}let v=he(g)[0];if(!v)throw new q({code:"embedded_wallet_creation_error",error:"Unknown error creating solana wallet"});return(d=(s=r.current)==null?void 0:s.onSuccess)==null||d.call(s,w),t({status:"connected",publicKey:v.public_key}),n({status:"initial"}),w}catch(c){let u=c instanceof Error?c.message:"Error creating embedded wallet";throw t({status:"error",error:u}),n({status:"initial"}),new q({code:"embedded_wallet_creation_error",error:u})}})}import{PrivyClientError as H}from"@privy-io/js-sdk-core";function we(u){return l(this,arguments,function*({client:e,account:t,setWallet:r,recoverWalletCallbacks:n,recoveryMethod:i,setRecoveryFlowState:o,password:a,recoveryKey:s,recoveryToken:d,recoverySecretOverride:c}){var m,p,w,g;if(!t)throw new H({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});switch(i){case"user-passcode":if(!a)throw new H({code:"embedded_wallet_recovery_error",error:"password is required for user-passcode recovery method"});break;case"google-drive":if(!d)throw new H({code:"embedded_wallet_recovery_error",error:"Recovery token is required for google-drive recovery method"});break;case"icloud":if(!c)throw new H({code:"embedded_wallet_recovery_error",error:"Record name is required for icloud recovery method"});break;case"recovery-encryption-key":if(!s)throw new H({code:"embedded_wallet_recovery_error",error:"recoveryKey is required for recovery-encryption-key recovery method"});break}r({status:"connecting",account:t});try{let v=yield e.embeddedWallet.getProvider(t,a,d,c,s);return r({status:"connected",provider:v,account:t}),o({status:"initial"}),(p=(m=n.current)==null?void 0:m.onSuccess)==null||p.call(m,v),v}catch(v){r({status:"needs-recovery",account:t}),o({status:"initial"});let y=new H({code:"embedded_wallet_recovery_error",error:v instanceof Error?v.message:"Error recovering embedded wallet"});throw(g=(w=n.current)==null?void 0:w.onError)==null||g.call(w,y),y}})}function Ct(s){return l(this,arguments,function*({client:e,account:t,entropyId:r,entropyIdVerifier:n,setSolanaWallet:i,recoverSolanaWalletCallbacks:o,setSolanaRecoveryFlowState:a}){var d,c,u,m;i({status:"connecting"});try{let p=yield e.embeddedWallet.getSolanaProvider(t,r,n);return i({status:"connected",publicKey:p._publicKey}),a({status:"initial"}),(c=(d=o.current)==null?void 0:d.onSuccess)==null||c.call(d,p),p}catch(p){i({status:"needs-recovery"}),a({status:"initial"});let w=new H({code:"embedded_wallet_recovery_error",error:p instanceof Error?p.message:"Error recovering embedded wallet"});throw(m=(u=o.current)==null?void 0:u.onError)==null||m.call(u,w),w}})}var xt=({client:e,solanaWallet:t,setSolanaWallet:r,setSolanaRecoveryFlowState:n,createSolanaWalletCallbacks:i,recoverSolanaWalletCallbacks:o})=>{let a=A(),s=Ne(()=>Xr(a),[a]),d=K(),c=Ne(()=>s.length===0?null:Wt(a),[a,s]),u=Ne(()=>{let g=s.map(S=>{let E=Wt(a,S);return E?{account:S,entropy:E}:null});if(g.some(S=>S===null))return[];let v=void 0,y=void 0,h=void 0;return g.filter(S=>S!==null).map(({account:S,entropy:{entropyId:E,entropyIdVerifier:C}})=>({address:S.address,publicKey:S.address,walletIndex:S.wallet_index,getProvider:()=>e.embeddedWallet.getSolanaProvider(S,E,C,v,y,h,k=>l(void 0,null,function*(){var x;yield(x=ye())==null?void 0:x(k)}))}))},[s,a,e]),m=Te(g=>l(void 0,null,function*(){return yield Et({client:e,setSolanaWallet:r,createSolanaWalletCallbacks:i,setSolanaRecoveryFlowState:n,opts:g})}),[e,i]),p=Te(()=>l(void 0,null,function*(){if(!c)throw new re({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});let{entropyId:g,entropyIdVerifier:v}=c;return Ct({client:e,account:s[0],entropyId:g,entropyIdVerifier:v,setSolanaWallet:r,recoverSolanaWalletCallbacks:o,setSolanaRecoveryFlowState:n})}),[e,c,s,o,n,r]),w=Te(()=>l(void 0,null,function*(){if(!c)throw r({status:"not-created"}),new re({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});r(g=>g.status==="connected"?{status:"reconnecting"}:{status:"connecting"});try{let{entropyId:g,entropyIdVerifier:v}=c,y=yield e.embeddedWallet.getSolanaProvider(s[0],g,v);return r({status:"connected",publicKey:s[0].public_key}),y}catch(g){throw Qr(g)?(r({status:"needs-recovery"}),new re({code:"embedded_wallet_needs_recovery",error:"Embedded wallet not loaded on device"})):g instanceof Error?(r({status:"error",error:g.message}),new re({code:"unknown_embedded_wallet_error",error:g.message})):(r({status:"error",error:"Error loading embedded wallet"}),new re({code:"unknown_embedded_wallet_error",error:"Error loading embedded wallet"}))}}),[s,e,c,r]);return kt(()=>{if(!a&&t.status!=="disconnected")return r({status:"disconnected"});d&&w().catch(()=>{})},[d,a]),kt(()=>{t.status==="error"&&t.error.includes("User must be logged in")&&w()},[t.status]),{create:m,recover:p,getProvider:w,wallets:u}};import{useCallback as ie,useEffect as It,useMemo as co}from"react";import{getUserEmbeddedEthereumWallet as lo,getUserEmbeddedSolanaWallet as Ot,isUnifiedWallet as uo,throwIfInvalidRecoveryUpgradePath as mo}from"@privy-io/js-sdk-core";import{errorIndicatesRecoveryIsNeeded as po,PrivyClientError as U}from"@privy-io/js-sdk-core";import{getUserEmbeddedEthereumWallet as Zr}from"@privy-io/js-sdk-core";import{PrivyClientError as G}from"@privy-io/js-sdk-core";function ve(m){return l(this,arguments,function*({client:e,setWallet:t,createWalletCallbacks:r,recoveryMethod:n,setRecoveryFlowState:i,password:o,recoveryKey:a,recoveryToken:s,recoverySecretOverride:d,iCloudRecordNameOverride:c,solanaAccount:u}){var w,g;switch(n){case"user-passcode":if(!o)throw new G({code:"embedded_wallet_recovery_error",error:"password is required for user-passcode recovery method"});break;case"recovery-encryption-key":if(!a)throw new G({code:"embedded_wallet_recovery_error",error:"key is required for recovery-encryption-key recovery method"});break;case"google-drive":if(!s)throw new G({code:"embedded_wallet_recovery_error",error:"Recovery token is required for google-drive recovery method"});break;case"icloud":if(!d||!c)throw new G({code:"embedded_wallet_recovery_error",error:"iCloud recovery failed due to inability to store credentials"});break}t({status:"creating",account:null});let p=n==="icloud"?"icloud-native":n;try{let{user:v}=yield e.embeddedWallet.create({password:o,recoveryMethod:p,recoveryKey:a,recoveryToken:s,recoverySecretOverride:d,iCloudRecordNameOverride:c,solanaAccount:u}),y=Zr(v);if(!y)throw new G({error:"Embedded wallet account not created",code:"embedded_wallet_creation_error"});let h=yield e.embeddedWallet.getProvider(y);return(g=(w=r.current)==null?void 0:w.onSuccess)==null||g.call(w,h),t({status:"connected",provider:h,account:y}),i({status:"initial"}),h}catch(v){let y=v instanceof Error?v.message:"Error creating embedded wallet";throw t({status:"error",error:y,account:null}),i({status:"initial"}),new G({code:"embedded_wallet_creation_error",error:y})}})}import{Platform as Pt}from"react-native";import{PrivyClientError as j}from"@privy-io/js-sdk-core";function At(){return l(this,null,function*(){try{return yield import("@privy-io/expo-native-extensions")}catch(e){throw new Error("@privy-io/expo-native-extensions not found. Ensure that you're explicitly including as a dependency, and running an Expo development build")}})}function oe(n){return l(this,arguments,function*({user:e,appId:t,client:r}){var s;if(Pt.OS==="android")throw new j({code:"embedded_wallet_recovery_error",error:"iCloud recovery is not supported on Android"});let i=yield At(),o=yield r.recovery.icloudAuth.getICloudConfiguration("expo-ios");if(!(o==null?void 0:o.container_identifier))throw new j({code:"embedded_wallet_recovery_error",error:"An iCloud Container ID must be specified in the Privy Dashboard."});try{let{recoverySecret:d,iCloudRecordName:c}=yield i.writeRecoverySecretToICloud({containerId:o.container_identifier,appId:t,userId:e.id});return{recoverySecret:d,iCloudRecordName:c}}catch(d){if(d instanceof Error){let c=(s=d.message.split("Caused by: ")[1])!=null?s:"Error writing to iCloud";throw new j({code:"embedded_wallet_recovery_error",error:c})}throw new j({code:"embedded_wallet_recovery_error",error:"Error writing to iCloud"})}})}function be(n){return l(this,arguments,function*({walletAddress:e,client:t,chainType:r}){var c;if(Pt.OS==="android")throw new j({code:"embedded_wallet_recovery_error",error:"iCloud recovery is not supported on Android"});let i=yield At(),a=(yield t.recovery.getRecoveryKeyMaterial(e,r)).icloud_record_name;if(!a)throw new j({code:"embedded_wallet_recovery_error",error:"iCloud recovery not properly backed up."});let s=yield t.recovery.icloudAuth.getICloudConfiguration("expo-ios"),d=s==null?void 0:s.container_identifier;if(!d)throw new j({code:"embedded_wallet_recovery_error",error:"An iCloud Container ID must be specified in the Privy Dashboard."});try{let{recoverySecret:u}=yield i.readRecoverySecretFromICloud({containerId:d,recordName:a});return{recoverySecret:u}}catch(u){if(u instanceof Error){let m=(c=u.message.split("Caused by: ")[1])!=null?c:"Error writing to iCloud";throw new j({code:"embedded_wallet_recovery_error",error:m})}throw new j({code:"embedded_wallet_recovery_error",error:"Error writing to iCloud"})}})}import*as z from"expo-linking";import*as Ut from"expo-web-browser";import{Platform as Rt}from"react-native";import{PrivyClientError as Y}from"@privy-io/js-sdk-core";import Aa from"react-fast-compare";import{PrivyApiError as eo,PrivyClientError as to}from"@privy-io/js-sdk-core";function _(e){return e instanceof Error||e instanceof eo||e instanceof to?e:typeof e=="string"?new Error(e):new Error("Unknown error")}var J=e=>new Promise(t=>setTimeout(t,e));import{useEffect as ro,useRef as oo}from"react";import{AppState as De}from"react-native";function Se(){let e=oo(De.currentState);ro(()=>De.addEventListener("change",n=>{e.current=n}).remove,[]);function t(){return De.currentState}return{appState:e,getCurrentAppState:t}}function ne(i){return l(this,arguments,function*({provider:e,redirectUri:t,client:r,onError:n}){try{let o;switch(e){case"google-drive":{let{url:c}=yield r.recovery.auth.generateURL(z.createURL(t||"/"));o=c;break}default:throw new Y({error:"OAuth invalid provider",code:"embedded_wallet_recovery_error"})}let a=yield Ut.openAuthSessionAsync(o);if(Rt.OS==="android")return;if(a.type!=="success")throw new Y({error:"Recovery OAuth session failed",code:"embedded_wallet_recovery_error"});let{queryParams:s}=z.parse(a.url),d;switch(e){case"google-drive":{let{privy_oauth_state:c,privy_oauth_code:u}=s;if(!u||!c)throw new Y({error:"Recovery OAuth invalid credentials",code:"embedded_wallet_recovery_error"});d=yield _e({oAuthCode:u,oAuthState:c,client:r});break}default:throw new Y({error:"Recovery OAuth invalid provider",code:"embedded_wallet_recovery_error"})}return d}catch(o){throw n==null||n(_(o)),o}})}function _e(n){return l(this,arguments,function*({oAuthCode:e,oAuthState:t,client:r}){let{access_token:i}=yield r.recovery.auth.authorize(e,t);if(!i)throw new Y({error:"OAuth invalid credentials",code:"login_with_oauth_returned_with_invalid_credentials"});return i})}var no=2*60*1e3;function io(e){let t;return new Promise((r,n)=>{t=z.addEventListener("url",o=>l(this,[o],function*({url:i}){if(!i)return;let{queryParams:a}=z.parse(i),{privy_oauth_state:s,privy_oauth_code:d}=a!=null?a:{};if(typeof d!="string"||typeof s!="string")return;let c=yield _e({client:e,oAuthCode:d,oAuthState:s});r(c)})),setTimeout(()=>{n(new Y({code:"embedded_wallet_set_recovery_error",error:"Failed to complete Google Drive recovery flow"}))},no)}).finally(()=>{t==null||t.remove()})}function Ee(e){return l(this,null,function*(){let t;Rt.OS==="android"&&(t=io(e));let r=yield ne({provider:"google-drive",client:e});return r!=null?r:yield t})}import{getUserEmbeddedWallet as ao,PrivyClientError as so}from"@privy-io/js-sdk-core";function Ce(o){return l(this,arguments,function*({client:e,recoveryInput:t,setWalletRecoveryCallbacks:r,setRecoveryFlowState:n,setWallet:i}){var a,s,d,c;try{let{provider:u,user:m}=yield e.embeddedWallet.setRecovery(t),p=u,w=ao(m);return i({status:"connected",provider:p,account:w}),(s=(a=r.current)==null?void 0:a.onSuccess)==null||s.call(a,p),n({status:"initial"}),p}catch(u){let m=new so({code:"embedded_wallet_set_recovery_error",error:u instanceof Error?u.message:"Error setting password on embedded wallet"});throw(c=(d=r.current)==null?void 0:d.onError)==null||c.call(d,m),n({status:"initial"}),m}})}function Lt(e){return e===void 0?{recoveryMethod:"privy"}:typeof e=="string"?{recoveryMethod:"user-passcode",password:e}:e.recoveryMethod==="user-passcode"?{recoveryMethod:"user-passcode",password:e.password}:e.recoveryMethod==="recovery-encryption-key"?{recoveryMethod:"recovery-encryption-key",recoveryKey:e.recoveryKey}:{recoveryMethod:e.recoveryMethod}}var Mt=({client:e,appId:t,wallet:r,setWallet:n,setRecoveryFlowState:i,createWalletCallbacks:o,recoverWalletCallbacks:a,setWalletRecoveryCallbacks:s})=>{let d=A(),c=co(()=>lo(d),[d]),u=K(),m=ie(y=>l(void 0,null,function*(){var ue,me;if(c)throw new U({error:"This user already has an embedded wallet",code:"embedded_wallet_already_exists"});let{user:h}=yield e.user.get(),{password:S,recoveryMethod:E,recoveryKey:C}=Lt(y),k,x,M;if(E==="google-drive"&&(k=yield ne({provider:E,client:e,onError:(ue=o.current)==null?void 0:ue.onError}),i({status:"creating-wallet"}),!k))return null;if(E==="icloud"){if(!h)throw new U({code:"embedded_wallet_recovery_error",error:"User must be loaded before creating a wallet with iCloud."});let{recoverySecret:Ue,iCloudRecordName:te}=yield oe({user:h,appId:t,client:e});x=Ue,M=te}return yield ve({client:e,setWallet:n,createWalletCallbacks:o,recoveryMethod:E,recoveryKey:C,setRecoveryFlowState:i,password:S,recoverySecretOverride:x,iCloudRecordNameOverride:M,solanaAccount:(me=Ot(h))!=null?me:void 0})}),[e,c,d]),p=ie(y=>l(void 0,null,function*(){var E;if(r.status!=="connected")throw new U({code:"attempted_to_set_password_before_connected",error:"Embedded wallet must be connected before setting password"});if(!c)throw new U({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});if(Ot(d))throw new U({code:"embedded_wallet_set_recovery_error",error:"Cannot set user-controlled recovery for a user with an embedded Solana wallet."});if(uo(c))throw new U({code:"unsupported_wallet_type",error:"Embedded wallet recovery is only supported for on-device execution and this app uses TEE execution. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide"});mo({currentRecoveryMethod:c.recovery_method,upgradeToRecoveryMethod:y.recoveryMethod});let h,S;switch(y.recoveryMethod){case"privy":S=D(P({},y),{wallet:c});break;case"user-passcode":S=D(P({},y),{wallet:c,password:y.password});break;case"google-drive":if(h=yield ne({provider:y.recoveryMethod,client:e,onError:(E=s.current)==null?void 0:E.onError}),i({status:"upgrading-recovery"}),!h)return null;S={recoveryMethod:"google-drive",wallet:c,recoveryAccessToken:h};break;case"icloud":if(!d)throw new U({code:"embedded_wallet_recovery_error",error:"User must be loaded before backing up to iCloud."});let{recoverySecret:C,iCloudRecordName:k}=yield oe({user:d,appId:t,client:e});S={recoveryMethod:"icloud-native",recoverySecretOverride:C,iCloudRecordNameOverride:k,wallet:c};break;default:throw new U({code:"embedded_wallet_recovery_error",error:"Unrecognized recovery method"})}return Ce({client:e,recoveryInput:S,setWalletRecoveryCallbacks:s,setRecoveryFlowState:i,setWallet:n})}),[e,c,r.status,d]),w=ie(y=>l(void 0,null,function*(){return p({recoveryMethod:"user-passcode",password:y})}),[e,c,r.status]),g=ie(y=>l(void 0,null,function*(){var x;if(!c)throw new U({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});let{password:h,recoveryMethod:S,recoveryKey:E}=Lt(y),C,k;if(S==="google-drive"&&(C=yield ne({provider:S,client:e,onError:(x=a.current)==null?void 0:x.onError}),i({status:"recovering"}),!C))return null;if(S==="icloud"){if(!d)throw new U({code:"embedded_wallet_recovery_error",error:"User must be loaded before recovering via iCloud."});let{recoverySecret:M}=yield be({client:e,walletAddress:c.address});k=M}return we({client:e,account:c,setWallet:n,recoverWalletCallbacks:a,recoveryMethod:S,setRecoveryFlowState:i,recoveryKey:E,password:h,recoveryToken:C,recoverySecretOverride:k})}),[e,c]),v=ie(()=>l(void 0,null,function*(){if(!c)throw n({status:"not-created",account:null}),new U({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});n(y=>y.status==="connected"?{status:"reconnecting",account:c}:{status:"connecting",account:c});try{let y=yield e.embeddedWallet.getProvider(c);return n({status:"connected",provider:y,account:c}),y}catch(y){throw po(y)?(n({status:"needs-recovery",account:c}),new U({code:"embedded_wallet_needs_recovery",error:"Embedded wallet not loaded on device"})):y instanceof Error?(n({status:"error",error:y.message,account:c}),new U({code:"unknown_embedded_wallet_error",error:y.message})):(n({status:"error",error:"Error loading embedded wallet",account:c}),new U({code:"unknown_embedded_wallet_error",error:"Error loading embedded wallet"}))}}),[e,c]);return It(()=>{if(!d&&r.status!=="disconnected")return n({status:"disconnected",account:null});u&&v().catch(()=>{})},[u,d,c]),It(()=>{r.status==="error"&&r.error.includes("User must be logged in")&&v()},[r.status]),{create:m,recover:g,setPassword:w,setRecovery:p,getProvider:v}};import{useEffect as yo,useState as fo}from"react";import{PrivyClientError as Ft}from"@privy-io/js-sdk-core";var Tt=({client:e,isReady:t})=>{let r=A(),n=ge(a=>a==null?void 0:a.customAuth),[i,o]=fo({status:"initial"});return yo(()=>{(()=>l(void 0,null,function*(){if(!(n!=null&&n.enabled)){o({status:"not-enabled"});return}o({status:"loading"});let{getCustomAccessToken:s,isLoading:d}=n;if(!(!t||d))try{let c=yield s();if(!c&&r){yield e.auth.logout(),o({status:"done"});return}if(!c){o({status:"done"});return}if(r){o({status:"done"});return}let u=W();if(!(yield e.auth.customProvider.syncWithToken(c,{embedded:u==null?void 0:u.embedded}))){yield e.auth.logout(),o({status:"error",error:new Ft({error:"Failed to sync with custom auth provider",code:"third_party_auth_error"})});return}o({status:"done"})}catch(c){if(console.log("Error syncing with custom auth provider",c),o({status:"error",error:c}),r)throw yield e.auth.logout(),new Ft({error:"Third-party auth failed",code:"third_party_auth_error"})}}))()},[e,r,t,n==null?void 0:n.enabled,n==null?void 0:n.getCustomAccessToken,n==null?void 0:n.isLoading]),{customAuthState:i,customAuthStateIsSettled:i.status!=="loading"&&i.status!=="initial"}};import*as $ from"expo-linking";import{useCallback as go,useEffect as ho,useMemo as wo}from"react";import{Platform as vo}from"react-native";import{getUserEmbeddedSolanaWallet as bo,getUserEmbeddedWallet as So}from"@privy-io/js-sdk-core";var Nt=({client:e,createWalletCallbacks:t,recoverWalletCallbacks:r,setWalletRecoveryCallbacks:n,recoveryFlowState:i,oAuthState:o,setRecoveryFlowState:a,setWallet:s,appStateVisible:d})=>{let c=$.useURL(),u=A(),m=wo(()=>So(u),[u]),p=K(),w=go(g=>{var y,h,S,E;let v=_(g);i.status==="creating-wallet"?(h=(y=t.current).onError)==null||h.call(y,_(v)):(E=(S=r.current).onError)==null||E.call(S,_(v)),a({status:"initial"})},[i]);return ho(()=>{function g(){return l(this,null,function*(){var S;if(!c&&i.status!=="initial"&&d&&w(new Error("Recovery OAuth session failed")),!c||i.status==="initial"||o.status!=="initial"||!d||!p)return;let{queryParams:v}=$.parse(c),{privy_oauth_state:y,privy_oauth_code:h}=v;if(!(!h||!y)){yield $.openURL(c.split("?")[0]);try{let E=yield _e({oAuthCode:h,oAuthState:y,client:e});if(i.status==="creating-wallet"){let C=(S=bo(u))!=null?S:void 0;yield ve({client:e,setWallet:s,createWalletCallbacks:t,recoveryMethod:"google-drive",setRecoveryFlowState:a,recoveryToken:E,solanaAccount:C})}else if(i.status==="upgrading-recovery"){if(!m)throw new Error("Embedded wallet not found");yield Ce({client:e,recoveryInput:{recoveryMethod:"google-drive",wallet:m,recoveryAccessToken:E},setWalletRecoveryCallbacks:n,setRecoveryFlowState:a,setWallet:s})}else yield we({client:e,account:m,setWallet:s,recoverWalletCallbacks:r,recoveryMethod:"google-drive",setRecoveryFlowState:a,recoveryToken:E})}catch(E){w(E)}}})}vo.OS==="android"&&g()},[c,i.status,d,p])};import{useEffect as _o}from"react";var Dt=({client:e,isUserInitialized:t,setIsUserInitialized:r,setError:n})=>{_o(()=>{t||(()=>l(void 0,null,function*(){try{yield e.initialize()}catch(o){n(o instanceof Error?o:new Error(String(o)))}try{yield e.user.get()}catch(o){}finally{r(!0)}}))()},[e,t,n,r])};import{useEffect as bi,useRef as Si}from"react";import{useCallback as je,useContext as Eo}from"react";import{PrivyClientError as Co}from"@privy-io/js-sdk-core";var Ms=e=>{let{client:t,setSiweState:r,siweState:n}=Eo(f),i=je(s=>{var c;let d=_(s);return r({status:"error",error:d}),(c=e==null?void 0:e.onError)==null||c.call(e,d),d},[e==null?void 0:e.onError]),o=je(u=>l(void 0,[u],function*({wallet:s,from:{domain:d,uri:c}}){var m;try{r({status:"generating-message"});let p=yield t.auth.siwe.init(s,d,c);return r({status:"awaiting-signature"}),(m=e==null?void 0:e.onGenerateMessage)==null||m.call(e,p.message),p.message}catch(p){throw i(p)}}),[t,i,e==null?void 0:e.onGenerateMessage]);return{loginWithSiwe:je(u=>l(void 0,[u],function*({signature:s,messageOverride:d,disableSignup:c}){var m;try{if(b())throw new Co({code:"attempted_login_with_siwe_while_already_logged_in",error:"Already logged in, use `useLinkWithSiwe` if you are trying to link a wallet to an existing account"});r({status:"submitting-signature"});let w=W(),g=yield t.auth.siwe.loginWithSiwe(s,void 0,d,c?"no-signup":"login-or-sign-up",{embedded:w==null?void 0:w.embedded});return r({status:"done"}),(m=e==null?void 0:e.onSuccess)==null||m.call(e,g.user,g.is_new_user),g.user}catch(p){throw i(p)}}),[t,i,e==null?void 0:e.onSuccess]),generateSiweMessage:o,state:n}};import{useCallback as jt}from"react";import{createSiwsMessage as Wo,PrivyClientError as xo}from"@privy-io/js-sdk-core";import{useContext as ko}from"react";var O=()=>{let{client:e}=ko(f);return e};var qs=()=>{let e=O(),t=jt(a=>l(void 0,[a],function*({wallet:{address:n},from:{domain:i,uri:o}}){try{let{nonce:s}=yield e.auth.siws.fetchNonce({address:n});return{message:Wo({address:n,domain:i,uri:o,nonce:s})}}catch(s){throw _(s)}}),[e]),r=jt(s=>l(void 0,[s],function*({signature:n,message:i,wallet:{walletClientType:o,connectorType:a}={}}){try{if(!b())throw new xo({code:"attempted_link_siws_before_logged_in",error:"Must be logged in to link a wallet, Use `useLoginWithSiws` to login with a wallet"});let{user:c}=yield e.auth.siws.link({signature:n,message:i,walletClientType:o,connectorType:a});return c}catch(d){throw _(d)}}),[e]);return{generateMessage:t,link:r}};import{useCallback as Vt}from"react";import{createSiwsMessage as Po,PrivyClientError as Ao}from"@privy-io/js-sdk-core";var tc=()=>{let e=O(),t=Vt(a=>l(void 0,[a],function*({wallet:{address:n},from:{domain:i,uri:o}}){try{let{nonce:s}=yield e.auth.siws.fetchNonce({address:n});return{message:Po({address:n,domain:i,uri:o,nonce:s})}}catch(s){throw _(s)}}),[e]),r=Vt(d=>l(void 0,[d],function*({signature:n,message:i,wallet:{walletClientType:o,connectorType:a}={},disableSignup:s}){try{if(b())throw new Ao({code:"attempted_login_with_siws_while_already_logged_in",error:"Already logged in, use `useLinkWithSiws` if you are trying to link a wallet to an existing account"});let u=W();return(yield e.auth.siws.login({signature:n,message:i,walletClientType:o,connectorType:a,mode:s?"no-signup":"login-or-sign-up",opts:{embedded:u==null?void 0:u.embedded}})).user}catch(c){throw _(c)}}),[e]);return{generateMessage:t,login:r}};import{useCallback as Kt,useContext as Uo}from"react";import{PrivyClientError as Ro}from"@privy-io/js-sdk-core";var dc=e=>{let{client:t}=Uo(f),r=Kt(i=>{var a;let o=_(i);return(a=e==null?void 0:e.onError)==null||a.call(e,o),o},[e==null?void 0:e.onError]);return{unlinkWallet:Kt(o=>l(void 0,[o],function*({address:i}){var a;try{if(!b())throw new Ro({code:"attempted_unlink_siwe_before_logged_in",error:"Must be logged in to unlink a wallet, Use `useLoginWithSiwe` to login with a wallet"});let{user:d}=yield t.auth.siwe.unlinkWallet(i);return(a=e==null?void 0:e.onSuccess)==null||a.call(e,d),d}catch(s){throw r(s)}}),[t,r,e==null?void 0:e.onSuccess])}};import{useCallback as Ve,useContext as Io,useState as Oo}from"react";import{PrivyClientError as Bt}from"@privy-io/js-sdk-core";var hc=e=>{let[t,r]=Oo(""),{client:n,otpState:i,setOtpState:o}=Io(f),a=Ve(c=>{var m;let u=_(c);return o({status:"error",error:u}),(m=e==null?void 0:e.onError)==null||m.call(e,u),u},[e,o]),s=Ve(u=>l(void 0,[u],function*({email:c}){var m;r(c);try{o({status:"sending-code"});let p=yield n.auth.email.sendCode(c);return o({status:"awaiting-code-input"}),(m=e==null?void 0:e.onSendCodeSuccess)==null||m.call(e,{email:c}),p}catch(p){throw a(p)}}),[n,a,e,o]),d=Ve(m=>l(void 0,[m],function*({code:c,email:u}){var p;try{if(!b())throw new Bt({code:"attempted_link_email_before_logged_in",error:"Must be logged in to link an email, Use `useLoginWithEmail` to login with email"});let g=u||t;if(!g)throw new Bt({code:"attempted_submit_otp_before_sending",error:"Must `sendCode` with a valid email before calling `linkWithCode`"});o({status:"submitting-code"});let{user:v}=yield n.auth.email.linkWithCode(g,c);return o({status:"done"}),(p=e==null?void 0:e.onLinkSuccess)==null||p.call(e,v),v}catch(w){throw a(w)}}),[t,o,n,e,a]);return{sendCode:s,linkWithCode:d,state:i}};import{useCallback as Ht,useContext as Lo}from"react";var Ec=e=>{let{client:t}=Lo(f),r=Ht(i=>{var a;let o=_(i);return(a=e==null?void 0:e.onError)==null||a.call(e,o),o},[e==null?void 0:e.onError]);return{unlinkEmail:Ht(o=>l(void 0,[o],function*({email:i}){var a;try{let{user:s}=yield t.auth.email.unlink(i);return(a=e==null?void 0:e.onSuccess)==null||a.call(e,s),s}catch(s){throw r(s)}}),[t,e==null?void 0:e.onSuccess,r])}};import{useCallback as Ke,useContext as Mo,useState as Fo}from"react";import{PrivyClientError as zt}from"@privy-io/js-sdk-core";var Ic=e=>{let[t,r]=Fo(""),{client:n,otpState:i,setOtpState:o}=Mo(f),a=Ke(c=>{var m;let u=_(c);return o({status:"error",error:u}),(m=e==null?void 0:e.onError)==null||m.call(e,u),u},[e,o]),s=Ke(u=>l(void 0,[u],function*({email:c}){var m;r(c);try{o({status:"sending-code"});let p=yield n.auth.email.sendCode(c);return o({status:"awaiting-code-input"}),(m=e==null?void 0:e.onSendCodeSuccess)==null||m.call(e,{email:c}),p}catch(p){throw a(p)}}),[n,a,e,o]),d=Ke(p=>l(void 0,[p],function*({code:c,email:u,disableSignup:m}){var w;try{if(b())throw new zt({code:"attempted_login_with_email_while_already_logged_in",error:"Already logged in, use `useLinkWithEmail` if you are trying to link an email to an existing account"});let v=u||t;if(!v)throw new zt({code:"attempted_submit_otp_before_sending",error:"Must `sendCode` with a valid email before calling `loginWithCode`"});o({status:"submitting-code"});let y=W(),h=yield n.auth.email.loginWithCode(v,c,m?"no-signup":"login-or-sign-up",{embedded:y==null?void 0:y.embedded});return o({status:"done"}),(w=e==null?void 0:e.onLoginSuccess)==null||w.call(e,h.user,h.is_new_user),h==null?void 0:h.user}catch(g){throw a(g)}}),[t,o,n,e,a]);return{sendCode:s,loginWithCode:d,state:i}};import{useCallback as Be,useContext as To,useState as No}from"react";import{PrivyClientError as qt}from"@privy-io/js-sdk-core";var jc=e=>{let[t,r]=No(""),{client:n,otpState:i,setOtpState:o}=To(f),a=Be(c=>{var m;let u=_(c);return o({status:"error",error:u}),(m=e==null?void 0:e.onError)==null||m.call(e,u),u},[e,o]),s=Be(u=>l(void 0,[u],function*({phone:c}){var m;r(c);try{o({status:"sending-code"});let p=yield n.auth.phone.sendCode(c);return o({status:"awaiting-code-input"}),(m=e==null?void 0:e.onSendCodeSuccess)==null||m.call(e,{phone:c}),p}catch(p){throw a(p)}}),[n,a,e,o]),d=Be(m=>l(void 0,[m],function*({code:c,phone:u}){var p;try{if(!b())throw new qt({code:"attempted_link_sms_before_logged_in",error:"Must be logged in to link a phone number, Use `useLoginWithSMS` to login with a phone number"});if(!(u||t))throw new qt({code:"attempted_submit_otp_before_sending",error:"Must `sendCode` with a valid phone number before calling `linkWithCode`"});o({status:"submitting-code"});let{user:v}=yield n.auth.phone.linkWithCode(u||t,c);return o({status:"done"}),(p=e==null?void 0:e.onLinkSuccess)==null||p.call(e,v),v}catch(w){throw a(w)}}),[t,o,n,e,a]);return{sendCode:s,linkWithCode:d,state:i}};import{useCallback as He,useContext as Do,useState as jo}from"react";import{PrivyClientError as Gt}from"@privy-io/js-sdk-core";var Yc=e=>{let[t,r]=jo(""),{client:n,otpState:i,setOtpState:o}=Do(f),a=He(c=>{var m;let u=_(c);return o({status:"error",error:u}),(m=e==null?void 0:e.onError)==null||m.call(e,u),u},[e,o]),s=He(u=>l(void 0,[u],function*({phone:c}){var m;r(c);try{o({status:"sending-code"});let p=yield n.auth.phone.sendCode(c);return o({status:"awaiting-code-input"}),(m=e==null?void 0:e.onSendCodeSuccess)==null||m.call(e,{phone:c}),p}catch(p){throw a(p)}}),[n,a,e,o]),d=He(p=>l(void 0,[p],function*({code:c,phone:u,disableSignup:m}){var w;try{if(b())throw new Gt({code:"attempted_login_with_sms_while_already_logged_in",error:"Already logged in, use `useLinkWithSMS` if you are trying to link a phone number to an existing account"});if(!(u||t))throw new Gt({code:"attempted_submit_otp_before_sending",error:"Must `sendCode` with a valid phone number before calling `loginWithCode`"});o({status:"submitting-code"});let y=W(),h=yield n.auth.phone.loginWithCode(u||t,c,m?"no-signup":"login-or-sign-up",{embedded:y==null?void 0:y.embedded});return o({status:"done"}),(w=e==null?void 0:e.onLoginSuccess)==null||w.call(e,h.user,h.is_new_user),h==null?void 0:h.user}catch(g){throw a(g)}}),[t,o,n,e,a]);return{sendCode:s,loginWithCode:d,state:i}};import*as ke from"expo-linking";import{useCallback as ze,useContext as Vo,useRef as Ko}from"react";import{PrivyClientError as ae}from"@privy-io/js-sdk-core";var od=e=>{let{appState:t,getCurrentAppState:r}=Se(),{client:n,farcasterState:i,setFarcasterState:o}=Vo(f),a=Ko(!1),s=ze(u=>{var p;let m=_(u);return o({status:"error",error:m}),(p=e==null?void 0:e.onError)==null||p.call(e,m),m},[e==null?void 0:e.onError,o]),d=ze(()=>{a.current=!0},[]);return{linkWithFarcaster:ze((w,...g)=>l(void 0,[w,...g],function*({relyingParty:u,redirectUrl:m},p={pollAttempts:10,pollIntervalMs:1e3}){var v;try{let y=b();if(a.current=!1,!y)throw new ae({code:"attempted_link_farcaster_before_logged_in",error:"Must be logged in to link a Farcaster account."});o({status:"generating-uri"});let{connect_uri:h,channel_token:S}=yield n.auth.farcaster.initializeAuth({relyingParty:u,redirectUrl:ke.createURL(m!=null?m:"/")});if(!h)throw new ae({code:"failed_to_generate_farcaster_uri",error:"Failed to generate farcaster uri"});if(!S)throw new ae({code:"failed_to_generate_farcaster_channel_token",error:"Failed to generate farcaster channel token"});yield ke.openURL(h),o({status:"polling-status"});let E=0;for(;E<p.pollAttempts;){if(a.current)throw new ae({code:"farcaster_polling_canceled",error:"Farcaster polling canceled"});if(t.current!=="active"&&r()!=="active"){yield J(p.pollIntervalMs);continue}let C=yield n.auth.farcaster.getFarcasterStatus({channel_token:S});if(C.state==="completed"){o({status:"submitting-token"});let{user:k}=yield n.auth.farcaster.link(P({channel_token:S},C));return o({status:"done"}),(v=e==null?void 0:e.onSuccess)==null||v.call(e,k),k}E++,yield J(p.pollIntervalMs)}throw new ae({code:"farcaster_polling_timeout",error:"Farcasting polling timed out"})}catch(y){throw s(y)}}),[n,e==null?void 0:e.onSuccess,s,o]),state:i,cancel:d}};import{useCallback as Jt,useContext as Bo}from"react";var dd=e=>{let{client:t}=Bo(f),r=Jt(i=>{var a;let o=_(i);return(a=e==null?void 0:e.onError)==null||a.call(e,o),o},[e==null?void 0:e.onError]);return{unlinkFarcaster:Jt(o=>l(void 0,[o],function*({fid:i}){var a;try{let{user:s}=yield t.auth.farcaster.unlink({fid:i});return(a=e==null?void 0:e.onSuccess)==null||a.call(e,s),s}catch(s){throw r(s)}}),[t,e==null?void 0:e.onSuccess,r])}};import*as We from"expo-linking";import{useCallback as Je,useContext as Ho,useRef as zo}from"react";import{PrivyClientError as se}from"@privy-io/js-sdk-core";var wd=e=>{let{appState:t,getCurrentAppState:r}=Se(),{client:n,farcasterState:i,setFarcasterState:o}=Ho(f),a=zo(!1),s=Je(u=>{var p;let m=_(u);return o({status:"error",error:m}),(p=e==null?void 0:e.onError)==null||p.call(e,m),m},[e==null?void 0:e.onError,o]),d=Je(()=>{a.current=!0},[]);return{loginWithFarcaster:Je((g,...v)=>l(void 0,[g,...v],function*({relyingParty:u,redirectUrl:m,disableSignup:p},w={pollAttempts:10,pollIntervalMs:1e3}){var y;try{if(a.current=!1,b())throw new se({code:"attempted_login_with_farcaster_while_already_logged_in",error:"Already logged in, use `useLinkWithFarcaster` if you are trying to link farcaster to an existing account"});o({status:"generating-uri"});let{connect_uri:S,channel_token:E}=yield n.auth.farcaster.initializeAuth({relyingParty:u,redirectUrl:We.createURL(m!=null?m:"/")});if(!S)throw new se({code:"failed_to_generate_farcaster_uri",error:"Failed to generate farcaster uri"});if(!E)throw new se({code:"failed_to_generate_farcaster_channel_token",error:"Failed to generate farcaster channel token"});yield We.openURL(S),o({status:"polling-status"});let C=0;for(;C<w.pollAttempts;){if(a.current)throw new se({code:"farcaster_polling_canceled",error:"Farcaster polling canceled"});if(t.current!=="active"&&r()!=="active"){yield J(w.pollIntervalMs);continue}let k=yield n.auth.farcaster.getFarcasterStatus({channel_token:E});if(k.state==="completed"){o({status:"submitting-token"});let x=W(),M=yield n.auth.farcaster.authenticate(P({channel_token:E,mode:p?"no-signup":"login-or-sign-up"},k),{embedded:x==null?void 0:x.embedded});return o({status:"done"}),(y=e==null?void 0:e.onSuccess)==null||y.call(e,M.user,M.is_new_user),M.user}C++,yield J(w.pollIntervalMs)}throw new se({code:"farcaster_polling_timeout",error:"Farcasting polling timed out"})}catch(h){throw s(h)}}),[n,s,e==null?void 0:e.onSuccess,o,t]),state:i,cancel:d}};import{useCallback as Yt,useContext as qo}from"react";import{create as Go}from"zustand";import{PrivyClientError as Jo}from"@privy-io/js-sdk-core";var Ye=Go(()=>({status:"initial"})),B=e=>Ye.setState(e,!0),Yo=Ye.getState,Pd=()=>{let{client:e}=qo(f),t=Ye(),r=Yt(()=>l(void 0,null,function*(){try{B({status:"fetching-nonce"});let i=yield e.auth.farcasterV2.initializeAuth();return B({status:"awaiting-signature"}),i}catch(i){let o=_(i);throw B({status:"initial",error:o}),o}}),[e]),n=Yt(i=>l(void 0,null,function*(){let o=Yo().status;try{if(b()){let c=new Jo({code:"attempted_login_with_farcaster_while_already_logged_in",error:"Already logged in, use a link helper if you are trying to link farcaster to an existing account"});throw B({status:o,error:c}),c}B({status:"submitting-signature"});let s=W(),d=yield e.auth.farcasterV2.authenticate(i,{embedded:s==null?void 0:s.embedded});return B({status:"done"}),setTimeout(()=>B({status:"initial"}),1500),{user:d.user}}catch(a){let s=_(a);throw B({status:o,error:s}),s}}),[e]);return{init:r,login:n,state:t}};import{useContext as $o,useMemo as Qo}from"react";import{delegatedActions as $t}from"@privy-io/js-sdk-core";var Ld=()=>{let{client:e}=$o(f);return Qo(()=>({delegateWallet:$t.delegateWallet(e),revokeWallets:$t.revokeWallets(e)}),[e])};import{useContext as en,useMemo as tn}from"react";import{addSessionSigners as rn,removeSessionSigners as on}from"@privy-io/js-sdk-core";import{isEmbeddedWalletAccount as Xo}from"@privy-io/js-sdk-core";function Zo(e,t){return e.linked_accounts.filter(Xo).find(r=>r.address===t)}function $e(e){let t=b();if(!t)throw new Error("User must be authenticated to perform this operation");let r=Zo(t,e);if(!r)throw new Error(`No wallet found with address ${e}`);return r}var Bd=()=>{let{client:e}=en(f);return tn(()=>({addSessionSigners:({address:t,signers:r})=>rn({client:e,wallet:$e(t),signers:r.map(n=>({signer_id:n.signerId,override_policy_ids:n.policyIds}))}),removeSessionSigners:({address:t})=>on({client:e,wallet:$e(t)})}),[e])};import{useContext as nn,useMemo as an}from"react";import{PrivyClientError as Xt}from"@privy-io/js-sdk-core";var Yd=()=>{let{client:e}=nn(f);return an(()=>({sendCode(n){return l(this,arguments,function*({newEmailAddress:r}){Qt(),yield e.auth.email.sendCode(r)})},updateEmail(i){return l(this,arguments,function*({newEmailAddress:r,code:n}){let{address:o}=Qt(),{user:a}=yield e.auth.email.updateEmail({oldEmailAddress:o,newEmailAddress:r,code:n});return a})}}),[e])};function Qt(){let t=sn().linked_accounts.find(r=>r.type==="email");if(!t)throw new Xt({code:"attempted_update_email_without_a_linked_email",error:"Must have a linked email account already to update an email address. Use `useLinkEmail` to link an email account."});return t}function sn(){let e=b();if(!e)throw new Xt({code:"attempted_update_before_logged_in",error:"Must be logged in to update a user profile."});return e}import{useContext as cn,useMemo as dn}from"react";import{PrivyClientError as er}from"@privy-io/js-sdk-core";var rl=()=>{let{client:e}=cn(f);return dn(()=>({sendCode(n){return l(this,arguments,function*({newPhoneNumber:r}){Zt(),yield e.auth.phone.sendCode(r)})},updatePhone(i){return l(this,arguments,function*({newPhoneNumber:r,code:n}){let{phoneNumber:o}=Zt(),{user:a}=yield e.auth.phone.updatePhone({oldPhoneNumber:o,newPhoneNumber:r,code:n});return a})}}),[e])};function Zt(){let t=ln().linked_accounts.find(r=>r.type==="phone");if(!t)throw new er({code:"attempted_update_phone_without_a_linked_phone",error:"Must have a linked phone account already to update a phone number. Use `useLinkSMS` to link a phone number."});return t}function ln(){let e=b();if(!e)throw new er({code:"attempted_update_before_logged_in",error:"Must be logged in to update a user profile."});return e}import*as or from"expo-linking";import{useCallback as mn,useContext as pn,useMemo as yn}from"react";import{crossApp as fn,PrivyClientError as gn}from"@privy-io/js-sdk-core";import*as rr from"expo-linking";import*as ce from"expo-web-browser";import{PrivyClientError as tr}from"@privy-io/js-sdk-core";var N=(e,t)=>l(void 0,null,function*(){let r=yield ce.openAuthSessionAsync(e,t,{createTask:!1});if(r.type!=="success")throw r.type===ce.WebBrowserResultType.CANCEL||r.type===ce.WebBrowserResultType.DISMISS?new tr({error:"OAuth session was cancelled",code:"oauth_session_failed"}):new tr({error:"OAuth session failed",code:"oauth_session_failed"});return un(r.url)});function un(e){let{queryParams:t}=rr.parse(e);return t}var pl=()=>{let{client:e}=pn(f),t=yn(()=>fn.loginWithCrossAppAuth({client:e,openAuthSession:N}),[e]);return{loginWithCrossApp:mn(o=>l(void 0,[o],function*({appId:n,redirectUri:i}){if(b())throw new gn({code:"attempted_login_with_cross_app_while_already_logged_in",error:"Already logged in, use `linkCrossAppAccount` if you are trying to link a cross app account to an existing account"});let{user:s}=yield t({providerAppId:n,redirectUrl:or.createURL(i||"/")});return{user:s}}),[t])}};import*as nr from"expo-linking";import{useCallback as hn,useContext as wn,useMemo as vn}from"react";import{crossApp as bn,PrivyClientError as Sn}from"@privy-io/js-sdk-core";var Sl=()=>{let{client:e}=wn(f),t=vn(()=>bn.linkWithCrossAppAuth({client:e,openAuthSession:N}),[e]);return{linkWithCrossApp:hn(o=>l(void 0,[o],function*({appId:n,redirectUri:i}){if(!b())throw new Sn({code:"attempted_link_cross_app_before_logged_in",error:"Must be logged in to link a cross app account, Use `loginWithCrossAppAccount` to login with cross app"});return{user:yield t({providerAppId:n,redirectUrl:nr.createURL(i||"/")})}}),[t])}};import*as ar from"expo-linking";import{useContext as _n,useMemo as ir}from"react";import{crossApp as En}from"@privy-io/js-sdk-core";var Al=()=>{let{client:e}=_n(f),t=ir(()=>En.wallet.signMessage({client:e,openAuthSession:N}),[e]);return ir(()=>({signMessage:({address:r,message:n,redirectUri:i="/"})=>t({user:b(),address:r,message:n,redirectUrl:ar.createURL(i)})}),[t])};import*as cr from"expo-linking";import{useContext as Cn,useMemo as sr}from"react";import{crossApp as kn}from"@privy-io/js-sdk-core";var Fl=()=>{let{client:e}=Cn(f),t=sr(()=>kn.wallet.signTypedData({client:e,openAuthSession:N}),[e]);return sr(()=>({signTypedData:({address:r,typedData:n,redirectUri:i="/"})=>t({user:b(),address:r,typedData:n,redirectUrl:cr.createURL(i)})}),[t])};import*as lr from"expo-linking";import{useContext as Wn,useMemo as dr}from"react";import{crossApp as xn}from"@privy-io/js-sdk-core";var Bl=()=>{let{client:e}=Wn(f),t=dr(()=>xn.wallet.sendTransaction({client:e,openAuthSession:N}),[e]);return dr(()=>({sendTransaction:({address:r,transaction:n,redirectUri:i="/"})=>t({user:b(),address:r,transaction:n,redirectUrl:lr.createURL(i)})}),[t])};import{useCallback as Pn,useContext as An}from"react";import{getUserEmbeddedEthereumWallet as Un,getUserEmbeddedSolanaWallet as Rn,isUnifiedWallet as In,PrivyClientError as Q,throwIfInvalidRecoveryUpgradePath as On}from"@privy-io/js-sdk-core";var Ql=()=>{let{client:e}=An(f);return{setRecovery:Pn(r=>l(void 0,null,function*(){var s;let n=b(),i=e.app.appId;if(!n)throw new Q({code:"embedded_wallet_recovery_error",error:"User must be loaded before attempting to modify the recovery method."});let o=(s=Un(n))!=null?s:Rn(n);if(!o)throw new Q({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});if(In(o))throw new Q({code:"unsupported_wallet_type",error:"Embedded wallet recovery is only supported for on-device execution and this app uses TEE execution. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide"});try{o.chain_type==="ethereum"?yield e.embeddedWallet.getProvider(o):o.chain_type==="solana"&&(yield e.embeddedWallet.getSolanaProvider(o,o.address,"solana-address-verifier"))}catch(d){throw new Q({code:"attempted_to_set_password_before_connected",error:"Embedded wallet must be connected before setting password"})}On({currentRecoveryMethod:o.recovery_method,upgradeToRecoveryMethod:r.recoveryMethod});let a=yield Ln({appId:i,client:e,user:n,primaryAccount:o,recoveryParams:r});try{let{user:d}=yield e.embeddedWallet.setRecovery(a);return{user:d}}catch(d){throw new Q({code:"embedded_wallet_set_recovery_error",error:d instanceof Error?d.message:"Error setting password on embedded wallet"})}}),[e])}},Ln=o=>l(void 0,[o],function*({appId:e,client:t,user:r,primaryAccount:n,recoveryParams:i}){switch(i.recoveryMethod){case"privy":return{recoveryMethod:"privy",wallet:n};case"user-passcode":return D(P({},i),{wallet:n});case"google-drive":{let a=yield Ee(t);return{recoveryMethod:"google-drive",wallet:n,recoveryAccessToken:a}}case"icloud":{let{recoverySecret:a,iCloudRecordName:s}=yield oe({appId:e,client:t,user:r});return{recoveryMethod:"icloud-native",recoverySecretOverride:a,iCloudRecordNameOverride:s,wallet:n}}case"recovery-encryption-key":return{recoveryMethod:"recovery-encryption-key",wallet:n,recoveryKey:i.recoveryKey};default:throw new Q({code:"embedded_wallet_recovery_error",error:"Unrecognized recovery method"})}});import{useCallback as Mn,useContext as Fn}from"react";import{getUserEmbeddedEthereumWallet as Tn,getUserEmbeddedSolanaWallet as Nn,PrivyClientError as de,isUnifiedWallet as Dn}from"@privy-io/js-sdk-core";var au=()=>{let{client:e}=Fn(f);return{recover:Mn(r=>l(void 0,null,function*(){var c;let n=b();if(!n)throw new de({code:"embedded_wallet_recovery_error",error:"User must be loaded before attempting to modify the recovery method."});let i=(c=Tn(n))!=null?c:Nn(n);if(!i)throw new de({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});if(Dn(i))throw new de({code:"unsupported_wallet_type",error:"User owned wallet recovery is only supported for on-device execution and this app uses TEE execution. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide"});let o,a,s,d;switch(r.recoveryMethod){case"user-passcode":a=r.password;break;case"google-drive":s=yield Ee(e);break;case"icloud":let{recoverySecret:u}=yield be({client:e,walletAddress:i.address,chainType:i.chain_type});d=u;break;case"recovery-encryption-key":o=r.recoveryKey;break;case"privy":break;default:throw new de({code:"unsupported_recovery_method",error:`Unsupported recovery options ${r}`})}try{i.chain_type==="ethereum"?yield e.embeddedWallet.getProvider(i,a,s,d,o):i.chain_type==="solana"&&(yield e.embeddedWallet.getSolanaProvider(i,i.address,"solana-address-verifier",a,s,d))}catch(u){throw new de({code:"attempted_to_set_password_before_connected",error:"Embedded wallet must be connected before setting password"})}}),[e])}};import{useEffect as Vn}from"react";import{useContext as jn,useEffect as Qe}from"react";var Xe=(e={})=>{let{wallet:t,createWalletCallbacks:r,recoverWalletCallbacks:n,setWalletRecoveryCallbacks:i}=jn(f),{onCreateWalletSuccess:o,onCreateWalletError:a,onRecoverWalletError:s,onRecoverWalletSuccess:d,onSetWalletRecoverySuccess:c,onSetWalletRecoveryError:u}=e;return Qe(()=>{r.current={onSuccess:o,onError:a}},[o,a]),Qe(()=>{n.current={onSuccess:d,onError:s}},[d,s]),Qe(()=>{i.current={onSuccess:c,onError:u}},[d,s]),t};var yu=({onStateChange:e})=>{let t=Xe();return Vn(()=>{e(t)},[t])};import{useContext as Kn}from"react";var wu=()=>{let{getIdentityToken:e}=Kn(f);return{getIdentityToken:e}};import{useCallback as ur,useContext as Bn}from"react";import{PrivyClientError as Hn}from"@privy-io/js-sdk-core";var Wu=e=>{let{client:t}=Bn(f),r=ur(i=>{var a;let o=_(i);return(a=e==null?void 0:e.onError)==null||a.call(e,o),o},[e==null?void 0:e.onError]);return{create:ur(()=>l(void 0,null,function*(){var i;try{if(b())throw new Hn({code:"attempted_to_create_guest_account_for_logged_in_user",error:"Already logged in, you cannot create a guest account"});let a=W(),s=yield t.auth.guest.create({embedded:a==null?void 0:a.embedded});return(i=e==null?void 0:e.onSuccess)==null||i.call(e,s.user,s.is_new_user),s.user}catch(o){throw r(o)}}),[t,r,e==null?void 0:e.onSuccess])}};import{useContext as zn,useEffect as qn}from"react";function Iu({onMfaRequired:e}){let{client:t}=zn(f);qn(()=>{function r(){return l(this,null,function*(){var i;let n=b();yield e((i=n==null?void 0:n.mfa_methods.map(({type:o})=>o))!=null?i:[])})}return t.mfaPromises.on("mfaRequired",r),()=>{t.mfaPromises.off("mfaRequired",r)}},[t,e])}import{useCallback as xe,useContext as Qn}from"react";import{PrivyClientError as Pe}from"@privy-io/js-sdk-core";import{PrivyClientError as Gn}from"@privy-io/js-sdk-core";var Jn=e=>l(void 0,null,function*(){var n;let r=yield(yield import("react-native-passkeys")).create({rp:e.rp,user:e.user,challenge:e.challenge,pubKeyCredParams:e.pubKeyCredParams,excludeCredentials:e.excludeCredentials,authenticatorSelection:e.authenticatorSelection,timeout:12e4});if(!r)throw new Gn({code:"failed_to_create_passkey",error:"Could not create passkey"});return D(P({},r),{type:(n=r.type)!=null?n:"public-key",clientExtensionResults:{}})});import{PrivyClientError as Yn}from"@privy-io/js-sdk-core";var et=e=>l(void 0,null,function*(){var n;let r=yield(yield import("react-native-passkeys")).get({rpId:e.rpId,challenge:e.challenge,allowCredentials:e.allowCredentials,timeout:12e4});if(!r)throw new Yn({code:"no_passkey_found_for_challenge",error:"Could not find a matching passkey to login with"});return D(P({},r),{type:(n=r.type)!=null?n:"public-key",clientExtensionResults:{}})});function mr(e){var t;return{id:e.id,client_extension_results:{app_id:e.clientExtensionResults.appid,cred_props:e.clientExtensionResults.credProps,hmac_create_secret:e.clientExtensionResults.hmacCreateSecret},raw_id:e.rawId,type:e.type,authenticator_attachment:(t=e.authenticatorAttachment)!=null?t:"platform",response:{authenticator_data:e.response.authenticatorData,client_data_json:e.response.clientDataJSON,signature:e.response.signature,user_handle:e.response.userHandle}}}function pr(e){var t,r,n,i;return{challenge:e.challenge,rpId:e.rp_id,extensions:{appid:(t=e.extensions)==null?void 0:t.app_id,credProps:(r=e.extensions)==null?void 0:r.cred_props,hmacCreateSecret:(n=e.extensions)==null?void 0:n.hmac_create_secret},timeout:e.timeout,allowCredentials:(i=e.allow_credentials)==null?void 0:i.map(({id:o,type:a,transports:s})=>({id:o,type:a,transports:s})),userVerification:e.user_verification}}function qu(e){var t,r,n,i,o,a,s,d;return{rp:e.rp,user:{id:e.user.id,name:e.user.name,displayName:e.user.display_name},challenge:e.challenge,pubKeyCredParams:e.pub_key_cred_params,extensions:{hmacCreateSecret:(t=e.extensions)==null?void 0:t.hmac_create_secret,credProps:(n=(r=e.extensions)==null?void 0:r.cred_props)==null?void 0:n.rk,appid:(i=e.extensions)==null?void 0:i.app_id},attestation:e.attestation,excludeCredentials:e.exclude_credentials,authenticatorSelection:{authenticatorAttachment:(o=e.authenticator_selection)==null?void 0:o.authenticator_attachment,residentKey:(a=e.authenticator_selection)==null?void 0:a.resident_key,userVerification:(s=e.authenticator_selection)==null?void 0:s.user_verification,requireResidentKey:(d=e.authenticator_selection)==null?void 0:d.require_resident_key}}}function Xu(){let{client:e}=Qn(f),t=xe(o=>l(this,null,function*(){var a,s;switch(o.method){case"sms":yield e.mfa.sms.sendCode({action:"verify"});return;case"passkey":let{options:d}=yield e.mfa.passkey.generateAuthenticationOptions({relying_party:o.relyingParty||((s=(a=W())==null?void 0:a.mfa)==null?void 0:s.relyingParty)});return pr(d);case"totp":return;default:throw new Error(`Unsupported MFA method: ${o.mfaMethod}`)}}),[e]),r=xe(o=>l(this,null,function*(){var a,s,d,c,u,m,p;switch(o.method){case"totp":case"sms":if(typeof o.mfaCode!="string")throw new Pe({code:"invalid_mfa_code",error:"Invalid MFA code"});(d=e.mfaPromises.rootPromise.current)==null||d.resolve({mfaMethod:o.method,mfaCode:o.mfaCode,relyingParty:o.relyingParty||((s=(a=W())==null?void 0:a.mfa)==null?void 0:s.relyingParty)||""}),yield new Promise((y,h)=>{e.mfaPromises.submitPromise.current={resolve:y,reject:h}});break;case"passkey":if(typeof o.mfaCode=="string")throw new Pe({code:"invalid_passkey_response",error:"Invalid authenticator response"});let w=yield et(o.mfaCode),g=mr(w);(m=e.mfaPromises.rootPromise.current)==null||m.resolve({mfaMethod:o.method,relyingParty:o.relyingParty||((u=(c=W())==null?void 0:c.mfa)==null?void 0:u.relyingParty)||"",mfaCode:g}),yield new Promise((y,h)=>{e.mfaPromises.submitPromise.current={resolve:y,reject:h}});break;default:let v=new Pe({code:"unsupported_mfa_method",error:"Unsupported MFA method"});throw(p=e.mfaPromises.rootPromise.current)==null||p.reject(v),v}}),[e]),n=xe(()=>l(this,null,function*(){let o=b();!o||o.mfa_methods.length===0||(yield e.mfa.verifyMfa())}),[e]),i=xe(()=>{var o;(o=e.mfaPromises.rootPromise.current)==null||o.reject(new Pe({code:"mfa_canceled",error:"MFA canceled"}))},[e]);return{init:t,submit:r,prompt:n,cancel:i}}import{useCallback as tt,useContext as Xn}from"react";function om(){let{client:e}=Xn(f),t=tt(i=>l(this,null,function*(){switch(i.method){case"sms":case"totp":return yield e.mfa.initEnrollMfa(i);case"passkey":return;default:throw new Error(`Unsupported MFA method: ${i.method}`)}}),[e]),r=tt(i=>l(this,null,function*(){switch(i.method){case"sms":case"totp":case"passkey":yield e.mfa.submitEnrollMfa(i);return;default:throw new Error(`Unsupported MFA method: ${i.method}`)}}),[e]),n=tt(i=>l(this,null,function*(){switch(i.method){case"sms":case"totp":yield e.mfa.unenrollMfa(i.method);return;case"passkey":yield e.mfa.submitEnrollMfa({method:"passkey",credentialIds:[],removeForLogin:i.removeForLogin});return;default:throw new Error(`Unsupported MFA method: ${i.method}`)}}),[e]);return{initMfaEnrollment:t,submitMfaEnrollment:r,unenrollMfa:n}}import{useCallback as Zn,useMemo as ei}from"react";import{getAllUserEmbeddedEthereumWallets as ot,getEntropyDetailsFromUser as yr,getUserEmbeddedSolanaWallet as ti,PrivyClientError as fr}from"@privy-io/js-sdk-core";var ri=()=>{let e=A(),t=O(),r=ei(()=>{let o=ot(e).map(a=>{let s=yr(e,a);return s?{account:a,entropy:s}:null});return o.some(a=>a===null)?[]:o.filter(a=>a!==null).map(({account:a,entropy:{entropyId:s,entropyIdVerifier:d}})=>({address:a.address,walletIndex:a.wallet_index,chainType:a.chain_type,getProvider:()=>t.embeddedWallet.getEthereumProvider({wallet:a,entropyId:s,entropyIdVerifier:d,onNeedsRecovery:c=>l(void 0,null,function*(){var u;yield(u=ye())==null?void 0:u(c)})})}))},[t,e]),n=Zn((...o)=>l(void 0,[...o],function*({createAdditional:i=!1}={}){let{user:a}=yield t.user.get(),s=ot(a);if(!i&&s.length>0)throw new fr({code:"embedded_wallet_creation_error",error:"Wallet already exists for this user. Set `createAdditional` to `true` to create another wallet"});let d=yr(a);if(!d){let g=yield t.embeddedWallet.create({});return rt(g.user,0),{user:g.user}}let{entropyId:c,entropyIdVerifier:u}=d;if(u==="solana-address-verifier"){let g=ti(a),v=yield t.embeddedWallet.create({solanaAccount:g});return rt(v.user,0),{user:v.user}}let p=s.map(g=>g.wallet_index).reduce((g,v)=>Math.max(g,v),0)+1,w=yield t.embeddedWallet.add({chainType:"ethereum",hdWalletIndex:p,entropyId:c,entropyIdVerifier:u});return rt(w.user,p),{user:w.user}}),[t]);return{wallets:r,create:n}};function rt(e,t){let r=ot(e).find(n=>n.wallet_index===t);if(!e||!r)throw new fr({code:"embedded_wallet_creation_error",error:"Unknown error creating wallet"})}import{useContext as oi,useEffect as gr}from"react";var ni=(e={})=>{let{solanaWallet:t,createSolanaWalletCallbacks:r,recoverSolanaWalletCallbacks:n}=oi(f),{onCreateWalletSuccess:i,onCreateWalletError:o,onRecoverWalletError:a,onRecoverWalletSuccess:s}=e;return gr(()=>{r.current={onSuccess:i,onError:o}},[i,o]),gr(()=>{n.current={onSuccess:s,onError:a}},[s,a]),t};import{useCallback as ii,useMemo as ai}from"react";import{getAllUserEmbeddedBitcoinWallets as nt,getEntropyDetailsFromUser as hr,isUnifiedWallet as si,PrivyClientError as X}from"@privy-io/js-sdk-core";var ci=()=>{let e=A(),t=O(),r=ai(()=>{let i=hr(e);if(!i)return[];let o=nt(e),{entropyId:a,entropyIdVerifier:s}=i;return o.map(d=>({address:d.address,walletIndex:d.wallet_index,publicKey:d.public_key,chainType:d.chain_type,getProvider:()=>si(d)?Promise.reject(new X({code:"unsupported_wallet_type",error:"Bitcoin wallet providers are only supported for on-device execution and this app uses TEE execution. Use the useSignRawHash hook from @privy-io/expo/extended-chains to sign over a hash with this wallet. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide"})):t.embeddedWallet.getBitcoinProvider({wallet:d,entropyId:a,entropyIdVerifier:s})}))},[t,e]),n=ii(a=>l(void 0,[a],function*({chainType:i,createAdditional:o=!1}){var y;let s=t.app.getConfig();if(((y=s==null?void 0:s.embedded_wallet_config)==null?void 0:y.mode)==="user-controlled-server-wallets-only")throw i==="bitcoin-segwit"?new X({code:"unsupported_wallet_type",error:"This app uses TEE execution. Use the useCreateWallet hook from @privy-io/expo/extended-chains to create the wallet instead. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide"}):new X({code:"unsupported_wallet_type",error:`Bitcoin (${i}) wallets are only supported for on-device execution and this app uses TEE execution. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide`});let{user:d}=yield t.user.get(),c=hr(d);if(!c)throw new X({code:"embedded_wallet_creation_error",error:"No existing wallet for this user, create an Ethereum walet first to add a Bitcoin wallet"});let{entropyId:u,entropyIdVerifier:m}=c,p=nt(d).filter(h=>h.chain_type===i);if(!o&&p.length>0)throw new X({code:"embedded_wallet_creation_error",error:"Wallet already exists for this user. Set `createAdditional` to `true` to create another wallet"});let w=p.length===0?0:Math.max(...p.map(h=>h.wallet_index),0)+1,g=yield t.embeddedWallet.add({chainType:i,hdWalletIndex:w,entropyId:u,entropyIdVerifier:m}),v=nt(g.user).find(h=>h.chain_type===i&&h.wallet_index===w);if(!g.user||!v)throw new X({code:"embedded_wallet_creation_error",error:"Unknown error creating wallet"});return{user:g.user,provider:yield t.embeddedWallet.getBitcoinProvider({wallet:v,entropyId:u,entropyIdVerifier:m})}}),[t]);return{wallets:r,create:n}};import{useContext as di}from"react";var it=()=>{let{isReady:e,logout:t,getAccessToken:r,error:n}=di(f);return{user:A(),isReady:e,error:n,logout:t,getAccessToken:r}};import{useMemo as li}from"react";import{generateAuthorizationSignature as ui}from"@privy-io/js-sdk-core";var mi=()=>{let e=O();return li(()=>({generateAuthorizationSignature(r){return l(this,null,function*(){let{signature:n}=yield ui((...i)=>e.embeddedWallet.signWithUserSigner(...i),r);return{signature:n}})}}),[e])};import{useCallback as wi}from"react";import{PrivyClientError as vi}from"@privy-io/js-sdk-core";import{getAllUserEmbeddedBitcoinWallets as pi,getUserEmbeddedEthereumWallet as yi,getUserEmbeddedSolanaWallet as fi,isEmbeddedWalletAccount as gi,isUnifiedWallet as hi}from"@privy-io/js-sdk-core";function wr(e,t){return l(this,null,function*(){var i;let r=(i=yi(t))!=null?i:fi(t);if(!r||hi(r))return{success:!0};if(r.imported)throw new Error("Imported wallets cannot be migrated");if(pi(t).length>0)throw new Error("Bitcoin wallets cannot be migrated");let n=t.linked_accounts.filter(gi).filter(o=>!o.imported).filter(o=>o.chain_type==="ethereum"||o.chain_type==="solana");return r.chain_type==="ethereum"?yield e.embeddedWallet.getProvider(r):r.chain_type==="solana"&&(yield e.embeddedWallet.getSolanaProvider(r,r.address,"solana-address-verifier")),yield e.embeddedWallet.delegateWallets({rootWallet:{address:r.address,chainType:r.chain_type,imported:r.imported},delegatedWallets:n.map(o=>({address:o.address,chainType:o.chain_type,walletIndex:o.wallet_index}))}),yield e.user.get(),{success:!0}})}var vr=()=>{let e=O();return{migrate:wi(()=>l(void 0,null,function*(){var o;let r=b(),n=e.app.getConfig();if(((o=n==null?void 0:n.embedded_wallet_config)==null?void 0:o.mode)!=="user-controlled-server-wallets-only")return{success:!0};if(!r)throw new vi({code:"embedded_wallet_before_logged_in",error:"User must be authenticated before migrating wallets"});return wr(e,r)}),[e])}};var br=({disabled:e})=>{let{migrate:t}=vr(),{user:r}=it(),n=Si(!1);return bi(()=>{e||r&&(n.current||(n.current=!0,t().then(()=>{console.info("Migrated wallets for user")}).catch(i=>{console.warn("Unable to migrate wallets: ",i)}).finally(()=>{n.current=!1})))},[t,r,e]),null};var f=Ei(null),ee;function zp(e){return ee?ee.getAccessToken():e!=null&&e.strict?Promise.reject(new Er({code:"attempted_to_read_storage_before_client_initialized",error:"Called `getAccessToken` before client initialized"})):(console.warn("Called `getAccessToken` before client initialized"),Promise.resolve(null))}var qp=e=>{var dt,lt,ut;Wi();let[t,r]=L(_r.currentState==="active");Sr(()=>{let I=_r.addEventListener("change",Rr=>{r(Rr==="active")});return()=>{I.remove()}},[]),Sr(()=>wt(e.config),[e.config]);let[n,i]=L(!1),[o,a]=L(null),[s,d]=L(!1),[c,u]=L({status:"disconnected",account:null}),[m,p]=L({status:"disconnected"}),[w,g]=L({status:"initial"}),[v,y]=L({status:"initial"}),[h,S]=L({status:"initial"}),[E,C]=L({status:"initial"}),[k,x]=L({status:"initial"}),[M,ue]=L({status:"initial"}),[me,Ue]=L({status:"initial"}),te=le({}),Re=le({}),Ie=le({}),st=le({}),ct=le({}),pe=Ae(I=>{if(I){Me(I),a(null);return}Me(null),g({status:"initial"}),y({status:"initial"}),u({status:"disconnected",account:null})},[]),R=_i(()=>{let I=e.storage||fe;return e.client?ee=e.client:ee=ht({appId:e.appId,clientId:e.clientId,supportedChains:e.supportedChains,storage:I,baseUrl:e.baseUrl,logLevel:e.logLevel}),ee.setCallbacks({setUser:pe,setIsReady:d}),ee},[e.client,e.storage,e.appId,e.clientId,e.baseUrl,e.supportedChains,e.logLevel,pe]),Cr=Ae(()=>{let I=b();return pe(null),R.auth.logout(I?{userId:I==null?void 0:I.id}:void 0)},[pe,R]),kr=Ae(()=>l(void 0,null,function*(){try{return yield R.getAccessToken()}catch(I){return console.debug(I),null}}),[R]),Wr=Ae(()=>R.getIdentityToken(),[R]);Dt({client:R,isUserInitialized:n,setIsUserInitialized:i,setError:a});let xr=Mt({client:R,appId:e.appId,createWalletCallbacks:te,recoverWalletCallbacks:Re,setWalletRecoveryCallbacks:Ie,setRecoveryFlowState:S,wallet:c,setWallet:u}),Pr=xt({client:R,createSolanaWalletCallbacks:st,recoverSolanaWalletCallbacks:ct,setSolanaRecoveryFlowState:C,solanaWallet:m,setSolanaWallet:p});Nt({client:R,createWalletCallbacks:te,recoverWalletCallbacks:Re,setWalletRecoveryCallbacks:Ie,recoveryFlowState:h,oAuthState:v,setRecoveryFlowState:S,setWallet:u,appStateVisible:t});let{customAuthStateIsSettled:Ar}=Tt({client:R,isReady:n}),Ur=K();return Z.createElement(Z.Fragment,null,Z.createElement(f.Provider,{value:{client:R,isReady:Ur&&n&&Ar,error:o,logout:Cr,getAccessToken:kr,getIdentityToken:Wr,wallet:P(P({},c),xr),solanaWallet:P(P({},m),Pr),oAuthState:v,recoveryFlowState:h,setRecoveryFlowState:S,solanaRecoveryFlowState:E,setSolanaRecoveryFlowState:C,createWalletCallbacks:te,recoverWalletCallbacks:Re,setWalletRecoveryCallbacks:Ie,createSolanaWalletCallbacks:st,recoverSolanaWalletCallbacks:ct,setOAuthState:y,siweState:k,setSiweState:x,otpState:w,setOtpState:g,passkeyState:M,setPasskeyState:ue,farcasterState:me,setFarcasterState:Ue}},e.children,Z.createElement(br,{disabled:(ut=(lt=(dt=e.config)==null?void 0:dt.embedded)==null?void 0:lt.disableAutomaticMigration)!=null?ut:!1})),Z.createElement(ki,{style:{width:0,height:0,overflow:"hidden"}},Z.createElement(St,{client:R,isClientReady:s})))},Wi=()=>{if(Ci(f))throw new Er({code:"configuration_error",error:"Found multiple instances of PrivyProvider, ensure there is only one mounted in your application tree."})};var ey=e=>{let{client:t,setSiweState:r,siweState:n}=xi(f),i=at(s=>{var c;let d=_(s);return r({status:"error",error:d}),(c=e==null?void 0:e.onError)==null||c.call(e,d),d},[e==null?void 0:e.onError]),o=at(u=>l(void 0,[u],function*({wallet:s,from:{domain:d,uri:c}}){var m;try{r({status:"generating-message"});let p=yield t.auth.siwe.init(s,d,c);return r({status:"awaiting-signature"}),(m=e==null?void 0:e.onGenerateMessage)==null||m.call(e,p.message),p.message}catch(p){throw i(p)}}),[t,i,e==null?void 0:e.onGenerateMessage]),a=at(c=>l(void 0,[c],function*({signature:s,messageOverride:d}){var u;try{if(!b())throw new Pi({code:"attempted_link_siwe_before_logged_in",error:"Must be logged in to link a wallet, Use `useLoginWithSiwe` to login with a wallet"});r({status:"submitting-signature"});let{user:p}=yield t.auth.siwe.linkWithSiwe(s,void 0,d);return r({status:"done"}),(u=e==null?void 0:e.onSuccess)==null||u.call(e,p),p}catch(m){throw i(m)}}),[t,i,e==null?void 0:e.onSuccess]);return{generateSiweMessage:o,linkWithSiwe:a,state:n}};export{W as a,b,Yi as c,A as d,$i as e,Lr as f,_ as g,J as h,fe as i,ht as j,ey as k,Ms as l,O as m,qs as n,tc as o,dc as p,hc as q,Ec as r,Ic as s,jc as t,Yc as u,od as v,dd as w,wd as x,Pd as y,Ld as z,Bd as A,Yd as B,rl as C,pl as D,Sl as E,Al as F,Fl as G,Bl as H,Ql as I,au as J,Xe as K,yu as L,wu as M,Wu as N,Iu as O,Jn as P,et as Q,qu as R,Xu as S,om as T,ri as U,ni as V,ci as W,it as X,mi as Y,vr as Z,f as _,zp as $,qp as aa};
