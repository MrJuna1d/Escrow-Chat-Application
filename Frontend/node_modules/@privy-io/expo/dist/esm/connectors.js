import{a as K,b as C,d as k}from"./chunk-OWCFWPAL.js";import{base58 as l}from"@scure/base";import*as i from"expo-linking";import*as x from"expo-secure-store";import{useState as z,useEffect as Q,useRef as $,useCallback as F}from"react";import v from"tweetnacl";var P=(s,d,c)=>`${s}/ul/v1/${d}?${c.toString()}`,b=(s,d)=>{if(!d)throw new Error("missing shared secret");let c=v.randomBytes(24),a=v.box.after(Buffer.from(JSON.stringify(s)),c,d);return{nonce:l.encode(c),data:l.encode(a)}},U=(s,d,c)=>{if(!c)throw new Error("missing shared secret");let a=v.box.open.after(l.decode(s),l.decode(d),c);if(!a)throw new Error("Unable to decrypt data");return JSON.parse(Buffer.from(a).toString("utf8"))},V=s=>JSON.stringify({publicKey:Array.from(s.publicKey),secretKey:Array.from(s.secretKey)}),X=s=>{let d=JSON.parse(s);return{publicKey:new Uint8Array(d.publicKey),secretKey:new Uint8Array(d.secretKey)}},B="wallet_keypair",q=6e4,D=({baseUrl:s,appUrl:d,redirectUri:c="/",encryptionPublicKeyName:a})=>{if(!s||!d||!c||!a)throw new Error("baseUrl, appUrl, redirectUri, and encryptionPublicKeyName are required");let[L,j]=z(!1),[u,M]=z(null),e=$(null),m=$(null),E=$(null),_=F(()=>k(void 0,null,function*(){if(E.current)return E.current;try{let o=yield x.getItemAsync(B);if(o){let r=X(o);return E.current=r,r}else{let r=v.box.keyPair();return E.current=r,yield x.setItemAsync(B,V(r)),r}}catch(o){throw console.error("Failed to initialize key pair:",o),o}}),[]),W=F(o=>k(void 0,null,function*(){var g;if(!o)return;let n=new URL(o).searchParams,p=n.get("wallet_id");if(!p||p!==a)return;if(n.get("errorCode")){let t=Object.fromEntries([...n]),y=(g=t==null?void 0:t.errorMessage)!=null?g:JSON.stringify(Object.fromEntries([...n]),null,2);console.error("Error from wallet provider: ",y);return}switch(n.get("wallet_action")){case"onConnect":try{if(!n.get("data")||!n.get("nonce")||!n.get(a))throw console.error("missing required fields in response"),new Error("missing required fields in response");let t=yield _(),y=v.box.before(l.decode(n.get(a)),t.secretKey),f=U(n.get("data"),n.get("nonce"),y);m.current=y,M(f),j(!0)}catch(t){console.error("Failed to process connect response:",t)}break;case"onSignMessage":try{if(!e.current||e.current.type!=="signMessage"){console.warn("Received signature response but no pending signature request");return}if(!n.get("data")||!n.get("nonce"))throw console.error("missing required fields in response"),new Error("missing required fields in response");let t=U(n.get("data"),n.get("nonce"),m.current);e.current.resolve(t),e.current=null}catch(t){console.error("Failed to process signature response:",t),e.current&&(e.current.reject(t),e.current=null)}break;case"onSignTransaction":try{if(!e.current||e.current.type!=="signTransaction"){console.warn("Received signature response but no pending signature request");return}if(!n.get("data")||!n.get("nonce"))throw console.error("missing required fields in response"),new Error("missing required fields in response");let t=U(n.get("data"),n.get("nonce"),m.current);e.current.resolve(t),e.current=null}catch(t){console.error("Failed to process transaction response:",t),e.current&&(e.current.reject(t),e.current=null)}break;case"onSignAndSendTransaction":try{if(!e.current||e.current.type!=="signAndSendTransaction"){console.warn("Received signature response but no pending signature request");return}if(!n.get("data")||!n.get("nonce"))throw console.error("missing required fields in response"),new Error("missing required fields in response");let t=U(n.get("data"),n.get("nonce"),m.current);e.current.resolve(t),e.current=null}catch(t){console.error("Failed to process transaction response:",t),e.current&&(e.current.reject(t),e.current=null)}break;case"onSignAllTransactions":try{if(!e.current||e.current.type!=="signAllTransactions"){console.warn("Received signature response but no pending signature request");return}if(!n.get("data")||!n.get("nonce"))throw console.error("missing required fields in response"),new Error("missing required fields in response");let t=U(n.get("data"),n.get("nonce"),m.current);e.current.resolve(t),e.current=null}catch(t){console.error("Failed to process transaction response:",t),e.current&&(e.current.reject(t),e.current=null)}break;case"onDisconnect":j(!1),M(null);break}}),[_,a]);Q(()=>{(()=>k(void 0,null,function*(){let n=yield i.getInitialURL();n&&W(n)}))();let r=i.addEventListener("url",({url:n})=>W(n).catch(p=>{e.current&&(e.current.reject(p),e.current=null)}));return()=>{r.remove()}},[a,W]);let I=()=>k(void 0,null,function*(){try{let o=yield _();if(!o)throw new Error("No dapp key pair found");let r={session:u==null?void 0:u.session},{nonce:n,data:p}=b(r,m.current),w=new URLSearchParams({nonce:n,dapp_encryption_public_key:l.encode(o.publicKey),redirect_link:`${i.createURL(c)}?wallet_action=onDisconnect&wallet_id=${a}`,payload:p}),g=P(s,"disconnect",w);yield i.openURL(g)}catch(o){throw console.error("Failed to disconnect:",o),o}}),N=o=>k(void 0,null,function*(){if(!L||!u)throw new Error("Wallet not connected");try{let r=yield _();if(!r)throw new Error("No dapp key pair found");let n={session:u.session,message:l.encode(Buffer.from(o)),display:"utf8"},{nonce:p,data:w}=b(n,m.current),g=new URLSearchParams({dapp_encryption_public_key:l.encode(r.publicKey),nonce:p,payload:w,redirect_link:`${i.createURL(c)}?wallet_action=onSignMessage&wallet_id=${a}`}),t=P(s,"signMessage",g);return new Promise((y,f)=>{i.openURL(t);let T=setTimeout(()=>{e.current&&(f(new Error("Signature request timed out")),e.current=null)},q),S=h=>{clearTimeout(T),y(h)},A=h=>{clearTimeout(T),f(h)};e.current={type:"signMessage",payload:o,resolve:S,reject:A}})}catch(r){throw e.current=null,console.error("Failed to sign message:",r),r}}),J=(o,r)=>k(void 0,null,function*(){if(!L||!u)throw new Error("Wallet not connected");try{let n=yield _();if(!n)throw new Error("No dapp key pair found");let p=o.serialize({requireAllSignatures:!1}),w={session:u.session,transaction:l.encode(p),sendOptions:r},{nonce:g,data:t}=b(w,m.current),y=new URLSearchParams({nonce:g,dapp_encryption_public_key:l.encode(n.publicKey),redirect_link:`${i.createURL(c)}?wallet_action=onSignAndSendTransaction&wallet_id=${a}`,payload:t}),f=P(s,"signAndSendTransaction",y);return new Promise((T,S)=>{i.openURL(f);let A=setTimeout(()=>{e.current&&(S(new Error("Signature request timed out")),e.current=null)},q),h=O=>{clearTimeout(A),T(O)},R=O=>{clearTimeout(A),S(O)};e.current={type:"signAndSendTransaction",payload:o,resolve:h,reject:R}})}catch(n){throw e.current=null,console.error("Failed to sign and send transaction:",n),n}}),Y=o=>k(void 0,null,function*(){if(!L||!u)throw new Error("Wallet not connected");try{let r=yield _();if(!r)throw new Error("No dapp key pair found");let p={transactions:o.map(f=>l.encode(f.serialize({requireAllSignatures:!1}))),session:u.session},{nonce:w,data:g}=b(p,m.current),t=new URLSearchParams({nonce:w,dapp_encryption_public_key:l.encode(r.publicKey),redirect_link:`${i.createURL(c)}?wallet_action=onSignAllTransactions&wallet_id=${a}`,payload:g}),y=P(s,"signAllTransactions",t);return new Promise((f,T)=>{i.openURL(y);let S=setTimeout(()=>{e.current&&(T(new Error("Signature request timed out")),e.current=null)},q),A=R=>{clearTimeout(S),f(R)},h=R=>{clearTimeout(S),T(R)};e.current={type:"signAllTransactions",payload:o,resolve:A,reject:h}})}catch(r){throw e.current=null,console.error("Failed to sign all transactions:",r),r}}),G=o=>k(void 0,null,function*(){if(!L||!u)throw new Error("Wallet not connected");try{let r=yield _();if(!r)throw new Error("No dapp key pair found");let n=o.serialize({requireAllSignatures:!1}),p={session:u.session,transaction:l.encode(n)},{nonce:w,data:g}=b(p,m.current),t=new URLSearchParams({nonce:w,dapp_encryption_public_key:l.encode(r.publicKey),redirect_link:`${i.createURL(c)}?wallet_action=onSignTransaction&wallet_id=${a}`,payload:g}),y=P(s,"signTransaction",t);return new Promise((f,T)=>{i.openURL(y);let S=setTimeout(()=>{e.current&&(T(new Error("Signature request timed out")),e.current=null)},q),A=R=>{clearTimeout(S),f(R)},h=R=>{clearTimeout(S),T(R)};e.current={type:"signTransaction",payload:o,resolve:A,reject:h}})}catch(r){throw e.current=null,console.error("Failed to sign transaction:",r),r}}),H=()=>k(void 0,null,function*(){let o=yield _();if(!o)throw new Error("No dapp key pair found");try{let r=new URLSearchParams({dapp_encryption_public_key:l.encode(o.publicKey),app_url:d,redirect_link:`${i.createURL(c)}?wallet_action=onConnect&wallet_id=${a}`}),n=P(s,"connect",r);yield i.openURL(n)}catch(r){console.error("Failed to open wallet connection:",r)}});return{address:u==null?void 0:u.public_key,connect:H,signMessage:N,signTransaction:G,signAndSendTransaction:J,signAllTransactions:Y,disconnect:I,isConnected:L}};var se=s=>D(C(K({},s),{baseUrl:"https://phantom.app",encryptionPublicKeyName:"phantom_encryption_public_key"}));var le=s=>D(C(K({},s),{baseUrl:"https://backpack.app",encryptionPublicKeyName:"wallet_encryption_public_key"}));export{le as useBackpackDeeplinkWalletConnector,D as useDeeplinkWalletConnector,se as usePhantomDeeplinkWalletConnector};
